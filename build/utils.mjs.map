{
  "version": 3,
  "sources": ["../src/utils.ts"],
  "sourcesContent": ["import { OpenAI } from \"openai\";\nimport { CursorPage, CursorPageParams } from \"openai/pagination.mjs\";\nimport {\n  DefaultListener,\n  ListenerSignature,\n  TypedEmitter,\n} from \"tiny-typed-emitter\";\n\nimport { CacheItemEvents, ObjectType } from \"./cache.js\";\nimport { Context } from \"./index.js\";\n\nexport interface StatefulObjectEvents<T> {\n  cacheInserted: (value: T) => void;\n  updated: (value: T) => void;\n  cacheRemoved: (value: T) => void;\n  fetched: (value: T) => void;\n  created: (value: T) => void;\n  deleted: (value: T) => void;\n}\n\nexport class StatefulObject<\n  Self extends StatefulObject<any, Wrapped, Events>,\n  Wrapped = any,\n  Events extends ListenerSignature<Events> = DefaultListener,\n> extends TypedEmitter<Events & StatefulObjectEvents<Self>> {\n  private _unsubscribe = () => {};\n\n  constructor(\n    protected _ctx: Context,\n    public readonly object: ObjectType,\n    private readonly _id: string,\n  ) {\n    super();\n    this._subscribe();\n  }\n\n  public get wrappedValue(): Wrapped {\n    const val = this._ctx.cache.get<Wrapped>(this.object, this._id);\n    if (!val) {\n      throw new Error(\n        \"Attempted to access wrapped value of a stateful object that has not been loaded. \" +\n          \"Do you need to call load()? Was the ID invalid?\",\n      );\n    }\n    return val;\n  }\n  protected get _cache() {\n    return this._ctx.cache;\n  }\n  public get id() {\n    return this._id;\n  }\n\n  /**\n   * Fetches the object into the cache. Does not overwrite the value in the cache if already exists.\n   */\n  public async load(options?: OpenAI.RequestOptions) {\n    await this._ctx.cache.getOrFetch(this.object, this._id, options);\n    this._subscribe();\n  }\n\n  /**\n   * Fetches the object into the cache. Overwrites the value in the cache if already exists.\n   */\n  public async fetch(options?: OpenAI.RequestOptions) {\n    await this._ctx.cache.fetch(this.object, this._id, options);\n  }\n\n  /** Re-emit events from the cache that pertain to this object */\n  private _subscribe() {\n    const listeners: Partial<CacheItemEvents<any>> = {};\n\n    const createListener = (key: keyof CacheItemEvents<any>) => {\n      listeners[key] = (id: string) => {\n        if (id === this._id) {\n          this.emit(key, ...([this] as any));\n        }\n      };\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n      return listeners[key] as any;\n    };\n\n    // cache.emitter throws error if cache is empty for this id\n    // TODO: Automatically subscribe to object-type-level or item-level events and switch between upon insert/remove?\n    if (!this._ctx.cache.get(this.object, this.id)) {\n      return;\n    }\n\n    this._unsubscribe();\n\n    const emitter = this._ctx.cache.emitter(this.object, this.id);\n    emitter.addListener(\"cacheInserted\", createListener(\"cacheInserted\"));\n    emitter.addListener(\"cacheRemoved\", createListener(\"cacheRemoved\"));\n    emitter.addListener(\"updated\", createListener(\"updated\"));\n    emitter.addListener(\"fetched\", createListener(\"fetched\"));\n    emitter.addListener(\"created\", createListener(\"created\"));\n    emitter.addListener(\"deleted\", createListener(\"deleted\"));\n\n    this._unsubscribe = () => {\n      for (const key in listeners) {\n        emitter.removeListener(\n          key as any,\n          listeners[key as keyof typeof listeners],\n        );\n      }\n      this._unsubscribe = () => {};\n    };\n  }\n\n  toString() {\n    return `${this.object}#${this.id}`;\n  }\n}\n\nexport interface WrappedPage<T> {\n  data: T[];\n  getNextPage: () => Promise<WrappedPage<T>>;\n  iterPages: () => AsyncGenerator<WrappedPage<T>>;\n  hasNextPage(): boolean;\n  nextPageInfo():\n    | { url: URL }\n    | { params: Record<string, unknown> | null }\n    | null;\n  nextPageParams(): Partial<CursorPageParams> | null;\n}\n\n/**\n * Facade on top of the page object that wraps results in StatefulObjects\n * @param ctx\n * @param page openai cursor page\n * @param initializer factory function to create the wrapped object\n */\nexport const createWrappedPage = <\n  Wrapped extends StatefulObject<any, Inner>,\n  Inner extends { id: string },\n>(\n  ctx: Context,\n  page: CursorPage<Inner>,\n  initializer: (ctx: Context, id: string) => Wrapped,\n): WrappedPage<Wrapped> => ({\n  data: page.data.map((item) => {\n    const value = initializer(ctx, item.id);\n    ctx.cache.set(value.object, item.id, item);\n    return value;\n  }),\n  getNextPage() {\n    return page\n      .getNextPage()\n      .then((page) => createWrappedPage(ctx, page, initializer));\n  },\n  hasNextPage: page.hasNextPage,\n  async *iterPages() {\n    yield await page\n      .iterPages()\n      .next()\n      .then((page) =>\n        createWrappedPage(ctx, page.value as CursorPage<Inner>, initializer),\n      );\n  },\n  nextPageInfo: page.nextPageInfo,\n  nextPageParams: page.nextPageParams,\n});\n"],
  "mappings": "AAEA;AAAA,EAGE;AAAA,OACK;AAcA,MAAM,uBAIH,aAAkD;AAAA,EAG1D,YACY,MACM,QACC,KACjB;AACA,UAAM;AAJI;AACM;AACC;AAGjB,SAAK,WAAW;AAAA,EAClB;AAAA,EATQ,eAAe,MAAM;AAAA,EAAC;AAAA,EAW9B,IAAW,eAAwB;AACjC,UAAM,MAAM,KAAK,KAAK,MAAM,IAAa,KAAK,QAAQ,KAAK,GAAG;AAC9D,QAAI,CAAC,KAAK;AACR,YAAM,IAAI;AAAA,QACR;AAAA,MAEF;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA,EACA,IAAc,SAAS;AACrB,WAAO,KAAK,KAAK;AAAA,EACnB;AAAA,EACA,IAAW,KAAK;AACd,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA,EAKA,MAAa,KAAK,SAAiC;AACjD,UAAM,KAAK,KAAK,MAAM,WAAW,KAAK,QAAQ,KAAK,KAAK,OAAO;AAC/D,SAAK,WAAW;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA,EAKA,MAAa,MAAM,SAAiC;AAClD,UAAM,KAAK,KAAK,MAAM,MAAM,KAAK,QAAQ,KAAK,KAAK,OAAO;AAAA,EAC5D;AAAA;AAAA,EAGQ,aAAa;AACnB,UAAM,YAA2C,CAAC;AAElD,UAAM,iBAAiB,CAAC,QAAoC;AAC1D,gBAAU,GAAG,IAAI,CAAC,OAAe;AAC/B,YAAI,OAAO,KAAK,KAAK;AACnB,eAAK,KAAK,KAAK,GAAI,CAAC,IAAI,CAAS;AAAA,QACnC;AAAA,MACF;AAEA,aAAO,UAAU,GAAG;AAAA,IACtB;AAIA,QAAI,CAAC,KAAK,KAAK,MAAM,IAAI,KAAK,QAAQ,KAAK,EAAE,GAAG;AAC9C;AAAA,IACF;AAEA,SAAK,aAAa;AAElB,UAAM,UAAU,KAAK,KAAK,MAAM,QAAQ,KAAK,QAAQ,KAAK,EAAE;AAC5D,YAAQ,YAAY,iBAAiB,eAAe,eAAe,CAAC;AACpE,YAAQ,YAAY,gBAAgB,eAAe,cAAc,CAAC;AAClE,YAAQ,YAAY,WAAW,eAAe,SAAS,CAAC;AACxD,YAAQ,YAAY,WAAW,eAAe,SAAS,CAAC;AACxD,YAAQ,YAAY,WAAW,eAAe,SAAS,CAAC;AACxD,YAAQ,YAAY,WAAW,eAAe,SAAS,CAAC;AAExD,SAAK,eAAe,MAAM;AACxB,iBAAW,OAAO,WAAW;AAC3B,gBAAQ;AAAA,UACN;AAAA,UACA,UAAU,GAA6B;AAAA,QACzC;AAAA,MACF;AACA,WAAK,eAAe,MAAM;AAAA,MAAC;AAAA,IAC7B;AAAA,EACF;AAAA,EAEA,WAAW;AACT,WAAO,GAAG,KAAK,MAAM,IAAI,KAAK,EAAE;AAAA,EAClC;AACF;AAoBO,MAAM,oBAAoB,CAI/B,KACA,MACA,iBAC0B;AAAA,EAC1B,MAAM,KAAK,KAAK,IAAI,CAAC,SAAS;AAC5B,UAAM,QAAQ,YAAY,KAAK,KAAK,EAAE;AACtC,QAAI,MAAM,IAAI,MAAM,QAAQ,KAAK,IAAI,IAAI;AACzC,WAAO;AAAA,EACT,CAAC;AAAA,EACD,cAAc;AACZ,WAAO,KACJ,YAAY,EACZ,KAAK,CAACA,UAAS,kBAAkB,KAAKA,OAAM,WAAW,CAAC;AAAA,EAC7D;AAAA,EACA,aAAa,KAAK;AAAA,EAClB,OAAO,YAAY;AACjB,UAAM,MAAM,KACT,UAAU,EACV,KAAK,EACL;AAAA,MAAK,CAACA,UACL,kBAAkB,KAAKA,MAAK,OAA4B,WAAW;AAAA,IACrE;AAAA,EACJ;AAAA,EACA,cAAc,KAAK;AAAA,EACnB,gBAAgB,KAAK;AACvB;",
  "names": ["page"]
}
