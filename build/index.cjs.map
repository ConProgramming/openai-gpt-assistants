{
  "version": 3,
  "sources": ["../node_modules/tiny-typed-emitter/lib/index.js", "../src/index.ts", "../src/cache.ts", "../src/utils.ts", "../src/assistant.ts", "../src/run.ts", "../src/message.ts", "../src/thread.ts"],
  "sourcesContent": ["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TypedEmitter = require(\"events\").EventEmitter;\n", "import { OpenAI } from \"openai\";\n\nimport { Cache } from \"./cache.js\";\nexport * from \"./assistant.js\";\nexport * from \"./cache.js\";\nexport * from \"./message.js\";\nexport * from \"./run.js\";\nexport * from \"./thread.js\";\n\ntype GlobalRequestOptions = Exclude<\n  OpenAI.RequestOptions,\n  \"method\" | \"body\" | \"query\" | \"path\"\n>;\n\nexport class Context {\n  cache: Cache;\n  constructor(\n    public readonly client: OpenAI,\n    public requestOptions: GlobalRequestOptions = {},\n  ) {\n    this.cache = new Cache(this);\n  }\n\n  _opts(options: OpenAI.RequestOptions): OpenAI.RequestOptions {\n    const opts = {\n      ...this.requestOptions,\n      ...options,\n    };\n    for (const key in opts) {\n      const casted = key as keyof typeof opts;\n      if (opts[casted] === undefined) {\n        delete opts[casted];\n      }\n    }\n    return opts;\n  }\n}\n", "import { OpenAI } from \"openai\";\nimport { TypedEmitter } from \"tiny-typed-emitter\";\n\nimport { Context } from \"./index.js\";\n\nexport type ObjectType = \"assistant\" | \"thread\" | \"message\" | \"run\";\nexport type Id = string;\ninterface CacheEvents<T> {\n  cacheInserted: (object: ObjectType, id: Id, value: T) => void;\n  updated: (object: ObjectType, id: Id, value: T) => void;\n  cacheRemoved: (object: ObjectType, id: Id, value: T) => void;\n  fetched: (object: ObjectType, id: Id, value: T) => void;\n  created: (object: ObjectType, id: Id, value: T) => void;\n  deleted: (object: ObjectType, id: Id, value: T) => void;\n}\nexport interface CacheItemEvents<T> {\n  cacheInserted: (id: Id, value: T) => void;\n  updated: (id: Id, value: T) => void;\n  cacheRemoved: (id: Id, value: T) => void;\n  fetched: (id: Id, value: T) => void;\n  created: (id: Id, value: T) => void;\n  deleted: (id: Id, value: T) => void;\n}\ninterface ObjectCacheItem<T> {\n  value: T;\n  emitter: TypedEmitter<CacheItemEvents<T>>;\n}\ninterface ObjectCache<T> {\n  data: Record<Id, ObjectCacheItem<T>>;\n  emitter: TypedEmitter<CacheItemEvents<T>>;\n}\nexport class Cache {\n  private _emitter = new TypedEmitter<CacheEvents<any>>();\n\n  private _cache: Record<ObjectType, ObjectCache<any>> = {\n    assistant: {\n      data: {},\n      emitter: new TypedEmitter<CacheItemEvents<any>>(),\n    },\n    thread: {\n      data: {},\n      emitter: new TypedEmitter<CacheItemEvents<any>>(),\n    },\n    message: {\n      data: {},\n      emitter: new TypedEmitter<CacheItemEvents<any>>(),\n    },\n    run: {\n      data: {},\n      emitter: new TypedEmitter<CacheItemEvents<any>>(),\n    },\n  };\n\n  constructor(private ctx: Context) {}\n\n  /**\n   * Returns the emitter for the entire cache; emits events for all objects.\n   */\n  emitter<T = any>(): TypedEmitter<CacheEvents<T>>;\n  /**\n   * Returns the emitter for a specific object type; emits events for all items of that type.\n   * @param object The object type to get the emitter for.\n   * @throws If the object type is invalid\n   */\n  emitter<T = any>(object: ObjectType): TypedEmitter<CacheItemEvents<T>>;\n  /**\n   * Returns the emitter for a specific object type and id; emits events for that specific item.\n   * @param object The object type\n   * @param id The id of the object\n   * @throws If the object type is invalid or the cache is empty for that id\n   */\n  emitter<T = any>(\n    object: ObjectType,\n    id: Id,\n  ): TypedEmitter<CacheItemEvents<T>>;\n  emitter<T = any>(object?: ObjectType, id?: Id) {\n    if (!object) return this._emitter as TypedEmitter<CacheEvents<T>>;\n\n    const cache = this._cache[object];\n    if (!cache) throw new Error(`Invalid object type ${object} to get emitter`);\n\n    if (!id) return cache.emitter as TypedEmitter<CacheItemEvents<T>>;\n\n    const item = cache.data[id];\n    if (!item)\n      throw new Error(`Cannot get emitter when cache is empty for id ${id}`);\n\n    return item.emitter as TypedEmitter<CacheItemEvents<T>>;\n  }\n\n  /**\n   * Emits an event for an item in the cache, the object type, and the entire cache.\n   */\n  _emit<T>(event: keyof CacheEvents<T>, object: ObjectType, id: Id, value?: T) {\n    this.emitter().emit(event, object, id, value);\n    this.emitter(object).emit(event, id, value);\n    this.emitter(object, id).emit(event, id, value);\n  }\n\n  /**\n   * Fetches an object from the API and caches it.\n   * First emits either 'cacheInserted' or 'updated' events, then emits a 'fetched' event.\n   * @param object ObjectType to fetch\n   * @param id Id of the object to fetch. For 'message' and 'run' objects, this is an object with a threadId and id property.\n   * @param options OpenAI.OpenAI.RequestOptions to pass to the fetch\n   * @throws If the object type is invalid\n   * @returns The fetched object\n   */\n  async fetch<T>(\n    object: ObjectType,\n    id: Id | { threadId: Id; id: Id },\n    options: OpenAI.RequestOptions = {},\n  ): Promise<T> {\n    let result: T;\n    const opts = this.ctx._opts(options);\n    switch (object) {\n      case \"assistant\":\n        if (typeof id !== \"string\")\n          throw new Error(`Invalid id type ${typeof id} to fetch an ${object}`);\n        result = (await this.ctx.client.beta.assistants.retrieve(\n          id,\n          opts,\n        )) as T;\n        break;\n      case \"thread\":\n        if (typeof id !== \"string\")\n          throw new Error(`Invalid id type ${typeof id} to fetch an ${object}`);\n        result = (await this.ctx.client.beta.threads.retrieve(id, opts)) as T;\n        break;\n      case \"message\":\n        if (typeof id !== \"object\")\n          throw new Error(`Invalid id type ${typeof id} to fetch an ${object}`);\n        result = (await this.ctx.client.beta.threads.messages.retrieve(\n          id.threadId,\n          id.id,\n          opts,\n        )) as T;\n        break;\n      case \"run\":\n        if (typeof id !== \"object\")\n          throw new Error(`Invalid id type ${typeof id} to fetch an ${object}`);\n        result = (await this.ctx.client.beta.threads.runs.retrieve(\n          id.threadId,\n          id.id,\n          opts,\n        )) as T;\n        break;\n      default:\n        throw new Error(`Invalid object type ${object} to fetch`);\n    }\n    const stringId: string = typeof id === \"object\" ? (id as any).id : id;\n    this.set(object, stringId, result);\n    this._emit(\"fetched\", object, stringId, result);\n    return result;\n  }\n\n  /**\n   * Returns an object from the cache, or fetches it from the API if it's not in the cache, emitting events in the process.\n   * @param object Object type\n   * @param id Object id\n   * @throws If the object type is invalid\n   */\n  async getOrFetch<T = any>(\n    object: ObjectType,\n    id: Id,\n    options?: OpenAI.RequestOptions,\n  ): Promise<T> {\n    const cache = this._cache[object] as ObjectCache<T>;\n    if (!cache) throw new Error(`Invalid object type ${object} to getOrFetch`);\n    const existing = cache.data[id];\n    if (existing) return existing.value;\n    return await this.fetch<T>(object, id, options);\n  }\n\n  /**\n   * Gets an object from the cache\n   * @param object Object type\n   * @param id Object id\n   * @throws If the object type is invalid\n   * @returns The object or undefined if it's not in the cache\n   */\n  get<T = any>(object: ObjectType, id: Id) {\n    const cache = this._cache[object] as ObjectCache<T>;\n    if (!cache) throw new Error(`Invalid object type ${object} to get`);\n    return (this._cache[object] as ObjectCache<T>).data[id]?.value;\n  }\n\n  /**\n   * Sets an object in the cache. If it already exists, emits an 'updated' event, otherwise emits an 'cacheInserted' event.\n   * @param object Object type\n   * @param id Object id\n   * @param value Value to insert\n   * @throws If the object type is invalid\n   */\n  set<T>(object: ObjectType, id: Id, value: T) {\n    const cache = this._cache[object] as ObjectCache<T>;\n    if (!cache) throw new Error(`Invalid object type ${object} to set`);\n    if (cache.data[id]) {\n      const data = cache.data[id]!;\n      if (data.value === value) return;\n      data.value = value;\n      this._emit(\"updated\", object, id, value);\n    } else {\n      cache.data[id] = {\n        value,\n        emitter: new TypedEmitter<CacheItemEvents<T>>(),\n      };\n      this._emit(\"cacheInserted\", object, id, value);\n    }\n  }\n\n  /** Removes an item from the cache. Emits a 'cacheRemoved' event. */\n  remove<T>(object: ObjectType, id: Id) {\n    const cache = this._cache[object] as ObjectCache<T>;\n    if (!cache) throw new Error(`Invalid object type ${object} to remove`);\n    if (cache.data[id]) {\n      const data = cache.data[id]!;\n      this._emit(\"cacheRemoved\", object, id);\n      data.emitter.removeAllListeners();\n      delete cache.data[id];\n    }\n  }\n}\n", "import { OpenAI } from \"openai\";\nimport { CursorPage, CursorPageParams } from \"openai/pagination.mjs\";\nimport {\n  DefaultListener,\n  ListenerSignature,\n  TypedEmitter,\n} from \"tiny-typed-emitter\";\n\nimport { CacheItemEvents, ObjectType } from \"./cache.js\";\nimport { Context } from \"./index.js\";\n\nexport interface StatefulObjectEvents<T> {\n  cacheInserted: (value: T) => void;\n  updated: (value: T) => void;\n  cacheRemoved: (value: T) => void;\n  fetched: (value: T) => void;\n  created: (value: T) => void;\n  deleted: (value: T) => void;\n}\n\nexport class StatefulObject<\n  Self extends StatefulObject<any, Wrapped, Events>,\n  Wrapped = any,\n  Events extends ListenerSignature<Events> = DefaultListener,\n> extends TypedEmitter<Events & StatefulObjectEvents<Self>> {\n  private _unsubscribe = () => {};\n\n  constructor(\n    protected _ctx: Context,\n    public readonly object: ObjectType,\n    private readonly _id: string,\n  ) {\n    super();\n    this._subscribe();\n  }\n\n  public get wrappedValue(): Wrapped {\n    const val = this._ctx.cache.get<Wrapped>(this.object, this._id);\n    if (!val) {\n      throw new Error(\n        \"Attempted to access wrapped value of a stateful object that has not been loaded. \" +\n          \"Do you need to call load()? Was the ID invalid?\",\n      );\n    }\n    return val;\n  }\n  protected get _cache() {\n    return this._ctx.cache;\n  }\n  public get id() {\n    return this._id;\n  }\n\n  /**\n   * Fetches the object into the cache. Does not overwrite the value in the cache if already exists.\n   */\n  public async load(options?: OpenAI.RequestOptions) {\n    await this._ctx.cache.getOrFetch(this.object, this._id, options);\n    this._subscribe();\n  }\n\n  /**\n   * Fetches the object into the cache. Overwrites the value in the cache if already exists.\n   */\n  public async fetch(options?: OpenAI.RequestOptions) {\n    await this._ctx.cache.fetch(this.object, this._id, options);\n  }\n\n  /** Re-emit events from the cache that pertain to this object */\n  private _subscribe() {\n    const listeners: Partial<CacheItemEvents<any>> = {};\n\n    const createListener = (key: keyof CacheItemEvents<any>) => {\n      listeners[key] = (id: string) => {\n        if (id === this._id) {\n          this.emit(key, ...([this] as any));\n        }\n      };\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n      return listeners[key] as any;\n    };\n\n    // cache.emitter throws error if cache is empty for this id\n    // TODO: Automatically subscribe to object-type-level or item-level events and switch between upon insert/remove?\n    if (!this._ctx.cache.get(this.object, this.id)) {\n      return;\n    }\n\n    this._unsubscribe();\n\n    const emitter = this._ctx.cache.emitter(this.object, this.id);\n    emitter.addListener(\"cacheInserted\", createListener(\"cacheInserted\"));\n    emitter.addListener(\"cacheRemoved\", createListener(\"cacheRemoved\"));\n    emitter.addListener(\"updated\", createListener(\"updated\"));\n    emitter.addListener(\"fetched\", createListener(\"fetched\"));\n    emitter.addListener(\"created\", createListener(\"created\"));\n    emitter.addListener(\"deleted\", createListener(\"deleted\"));\n\n    this._unsubscribe = () => {\n      for (const key in listeners) {\n        emitter.removeListener(\n          key as any,\n          listeners[key as keyof typeof listeners],\n        );\n      }\n      this._unsubscribe = () => {};\n    };\n  }\n\n  toString() {\n    return `${this.object}#${this.id}`;\n  }\n}\n\nexport interface WrappedPage<T> {\n  data: T[];\n  getNextPage: () => Promise<WrappedPage<T>>;\n  iterPages: () => AsyncGenerator<WrappedPage<T>>;\n  hasNextPage(): boolean;\n  nextPageInfo():\n    | { url: URL }\n    | { params: Record<string, unknown> | null }\n    | null;\n  nextPageParams(): Partial<CursorPageParams> | null;\n}\n\n/**\n * Facade on top of the page object that wraps results in StatefulObjects\n * @param ctx\n * @param page openai cursor page\n * @param initializer factory function to create the wrapped object\n */\nexport const createWrappedPage = <\n  Wrapped extends StatefulObject<any, Inner>,\n  Inner extends { id: string },\n>(\n  ctx: Context,\n  page: CursorPage<Inner>,\n  initializer: (ctx: Context, id: string) => Wrapped,\n): WrappedPage<Wrapped> => ({\n  data: page.data.map((item) => {\n    const value = initializer(ctx, item.id);\n    ctx.cache.set(value.object, item.id, item);\n    return value;\n  }),\n  getNextPage() {\n    return page\n      .getNextPage()\n      .then((page) => createWrappedPage(ctx, page, initializer));\n  },\n  hasNextPage: page.hasNextPage,\n  async *iterPages() {\n    yield await page\n      .iterPages()\n      .next()\n      .then((page) =>\n        createWrappedPage(ctx, page.value as CursorPage<Inner>, initializer),\n      );\n  },\n  nextPageInfo: page.nextPageInfo,\n  nextPageParams: page.nextPageParams,\n});\n", "import { OpenAI } from \"openai/index.mjs\";\n\nimport { Context } from \"./index.js\";\nimport { createWrappedPage, StatefulObject } from \"./utils.js\";\n\nexport interface AssistantEvents {}\n\nexport class Assistant extends StatefulObject<\n  Assistant,\n  OpenAI.Beta.Assistant,\n  AssistantEvents\n> {\n  constructor(ctx: Context, id: string) {\n    super(ctx, Assistant.object, id);\n  }\n\n  static readonly object = \"assistant\";\n  readonly object = Assistant.object;\n  get name() {\n    return this.wrappedValue.name;\n  }\n  get description() {\n    return this.wrappedValue.description;\n  }\n  get instructions() {\n    return this.wrappedValue.instructions;\n  }\n  get model() {\n    return this.wrappedValue.model;\n  }\n  get fileIds() {\n    return this.wrappedValue.file_ids;\n  }\n  get createdAt() {\n    return new Date(this.wrappedValue.created_at * 1000);\n  }\n  get metadata() {\n    return this.wrappedValue.metadata;\n  }\n  get tools() {\n    return this.wrappedValue.tools;\n  }\n\n  /**\n   * Create an assistant with a model and instructions.\n   */\n  static async create(\n    ctx: Context,\n    params: OpenAI.Beta.AssistantCreateParams,\n    options: OpenAI.RequestOptions = {},\n  ) {\n    const assistant = await ctx.client.beta.assistants.create(\n      params,\n      ctx._opts(options),\n    );\n    ctx.cache.set(this.object, assistant.id, assistant);\n    ctx.cache._emit(\"created\", this.object, assistant.id, assistant);\n    const created = new Assistant(ctx, assistant.id);\n    return created;\n  }\n\n  /** Constructs a new assistant object by fetching by id or returning from cache if already present. */\n  static async load(ctx: Context, id: string, options?: OpenAI.RequestOptions) {\n    const assistant = new Assistant(ctx, id);\n    await assistant.load(options);\n    return assistant;\n  }\n\n  /**\n   * Deletes this assistant.\n   */\n  async delete(options: OpenAI.RequestOptions = {}) {\n    const deleted = await this._ctx.client.beta.assistants.del(\n      this.wrappedValue.id,\n      this._ctx._opts(options),\n    );\n    if (deleted.deleted) {\n      this._cache._emit(\"deleted\", this.object, this.wrappedValue.id);\n      this._cache.remove(this.object, this.wrappedValue.id);\n    }\n    return deleted;\n  }\n\n  /**\n   * Returns a list of assistants.\n   */\n  static async list(ctx: Context, options: OpenAI.RequestOptions = {}) {\n    const page = await ctx.client.beta.assistants.list(ctx._opts(options));\n    const wrapped = createWrappedPage(\n      ctx,\n      page,\n      (ctx, id) => new Assistant(ctx, id),\n    );\n    return wrapped;\n  }\n\n  /**\n   * Modifies this assistant.\n   */\n  async update(\n    params: OpenAI.Beta.AssistantUpdateParams,\n    options: OpenAI.RequestOptions = {},\n  ) {\n    const assistant = await this._ctx.client.beta.assistants.update(\n      this.wrappedValue.id,\n      params,\n      this._ctx._opts(options),\n    );\n    this._cache.set(this.object, assistant.id, assistant);\n    return this;\n  }\n}\n", "import { OpenAI } from \"openai\";\n\nimport { Assistant, Context } from \"./index.js\";\nimport { Thread } from \"./thread.js\";\nimport { createWrappedPage, StatefulObject } from \"./utils.js\";\n\nconst POLL_INTERVAL_MS = 750;\nconst POLL_TIMEOUT_MS = 1000 * 60 * 2; // 2 minutes\n\nexport interface RunEvents {\n  statusChanged: (status: RunStatus) => void;\n  actionRequired: (\n    action: OpenAI.Beta.Threads.Runs.Run[\"required_action\"],\n  ) => void;\n  finished: (err: unknown, status: RunStatus | null) => void;\n}\n\nexport type RunStatus = OpenAI.Beta.Threads.Runs.Run[\"status\"];\n\nexport class Run extends StatefulObject<\n  Run,\n  OpenAI.Beta.Threads.Runs.Run,\n  RunEvents\n> {\n  private _pollInterval: ReturnType<typeof setInterval> | null = null;\n  private _pollStartTime = 0;\n\n  constructor(\n    ctx: Context,\n    public thread: Thread,\n    id: string,\n  ) {\n    super(ctx, Run.object, id);\n  }\n\n  static readonly object = \"run\";\n  readonly object = Run.object;\n\n  /** Retrieves from cache or fetches if missing, then begins polling. */\n  async load(options?: OpenAI.RequestOptions) {\n    await super.load(options);\n    this.beginPolling();\n  }\n\n  /** Creates a Run and begins a polling process to check its status. */\n  static async create(\n    ctx: Context,\n    thread: Thread,\n    params: RunCreateParams,\n    options: OpenAI.RequestOptions = {},\n  ) {\n    const { assistant, ...rest } = params;\n    const runParams = { ...rest, assistant_id: assistant.id };\n\n    const run = await ctx.client.beta.threads.runs.create(\n      thread.id,\n      runParams,\n      options,\n    );\n    ctx.cache.set(this.object, run.id, run);\n    ctx.cache._emit(\"created\", this.object, run.id, run);\n    const created = new Run(ctx, thread, run.id);\n    created.beginPolling();\n    return created;\n  }\n\n  /** Constructs a new Run object by fetching by id or returning from cache if already present. */\n  static async load(\n    ctx: Context,\n    thread: Thread,\n    id: string,\n    options?: OpenAI.RequestOptions,\n  ) {\n    const run = new Run(ctx, thread, id);\n    await run.load(options);\n    return run;\n  }\n\n  /**\n   * Returns a list of Runs from a Thread.\n   */\n  static async list(\n    ctx: Context,\n    thread: Thread,\n    options: OpenAI.RequestOptions = {},\n  ) {\n    const page = await ctx.client.beta.threads.runs.list(\n      thread.id,\n      ctx._opts(options),\n    );\n    return createWrappedPage(ctx, page, (ctx, id) => new Run(ctx, thread, id));\n  }\n\n  /** Modifies this Run */\n  async update(\n    params: OpenAI.Beta.Threads.RunUpdateParams,\n    options: OpenAI.RequestOptions = {},\n  ) {\n    const result = await this._ctx.client.beta.threads.runs.update(\n      this.thread.id,\n      this.id,\n      params,\n      options,\n    );\n    this._cache.set(this.object, this.id, result);\n    return this;\n  }\n\n  /** Cancels this Run */\n  async cancel(options: OpenAI.RequestOptions = {}) {\n    const result = await this._ctx.client.beta.threads.runs.cancel(\n      this.thread.id,\n      this.id,\n      options,\n    );\n    this._cache.set(this.object, this.id, result);\n    return this;\n  }\n\n  /**\n   * Submits tool outputs to this Run.\n   */\n  async submitToolOutputs(\n    params: OpenAI.Beta.Threads.RunSubmitToolOutputsParams,\n    options: OpenAI.RequestOptions = {},\n  ) {\n    const result = await this._ctx.client.beta.threads.runs.submitToolOutputs(\n      this.thread.id,\n      this.id,\n      params,\n      options,\n    );\n    this._cache.set(this.object, this.id, result);\n    return this;\n  }\n\n  /**\n   * Returns a list of steps from this Run. Steps aren't cached.\n   */\n  async listSteps(options: OpenAI.RequestOptions = {}) {\n    const page = await this._ctx.client.beta.threads.runs.steps.list(\n      this.thread.id,\n      this.id,\n      options,\n    );\n    return page;\n  }\n\n  /**\n   * Gets a step by id. Steps aren't cached.\n   */\n  async fetchStep(id: string, options: OpenAI.RequestOptions = {}) {\n    const step = await this._ctx.client.beta.threads.runs.steps.retrieve(\n      this.thread.id,\n      this.id,\n      id,\n      options,\n    );\n    return step;\n  }\n\n  /**\n   * Waits until this emitter emits a finished event, then returns the status.\n   */\n  async waitUntilFinished() {\n    if (this._pollInterval === null) {\n      this.beginPolling();\n    }\n    return new Promise<RunStatus>((resolve, reject) => {\n      this.once(\"finished\", (err, status) => {\n        if (err) reject(err);\n        else resolve(status!);\n      });\n    });\n  }\n\n  /**\n   * Polls the Run until it has finished. Emits events when the status changes.\n   *\n   * Note - for requires_action status, the actionRequired event will be emitted, then you can call submitToolOutputs()\n   */\n  beginPolling(options: OpenAI.RequestOptions = {}) {\n    // Clear existing polling interval if it exists\n    this.endPolling();\n\n    // Start timer\n    this._pollStartTime = Date.now();\n    // Begin polling interval\n    this._pollInterval = setInterval(async () => {\n      // Check if polling has timed out and exit if so\n      const elapsed = Date.now() - this._pollStartTime;\n      if (elapsed > POLL_TIMEOUT_MS) {\n        this.endPolling();\n        this.emit(\n          \"finished\",\n          new Error(\n            `Polling for Run id ${this.id} timed out after ${\n              POLL_TIMEOUT_MS / 1000\n            } seconds`,\n          ),\n          null,\n        );\n        return;\n      }\n\n      // Fetch the run and emit events if the status has changed\n      const oldRun = this.wrappedValue;\n      let run: OpenAI.Beta.Threads.Runs.Run;\n      try {\n        run = await this._ctx.cache.fetch<OpenAI.Beta.Threads.Runs.Run>(\n          Run.object,\n          { id: this.id, threadId: this.thread.id },\n          options,\n        );\n      } catch (err) {\n        console.error(`Error fetching Run id ${this.id} during polling:`, err);\n        this.emit(\"finished\", err, null);\n        this.endPolling();\n        return;\n      }\n      if (run.status !== oldRun.status) this.emit(\"statusChanged\", run.status);\n\n      // Emit actionRequired event if the run requires action\n      if (run.status === \"requires_action\") {\n        this.emit(\"actionRequired\", run.required_action);\n      }\n\n      // Emit finished event if the run has finished and end polling\n      const exitStatuses: RunStatus[] = [\n        \"cancelled\",\n        \"expired\",\n        \"completed\",\n        \"failed\",\n      ];\n      if (exitStatuses.includes(run.status)) {\n        this.endPolling();\n        await this.thread.fetch();\n        this.emit(\"finished\", null, run.status);\n        return;\n      }\n    }, POLL_INTERVAL_MS);\n  }\n\n  endPolling() {\n    clearInterval(this._pollInterval!);\n    this._pollInterval = null;\n    this._pollStartTime = 0;\n  }\n}\n\nexport interface RunCreateParams\n  extends Omit<OpenAI.Beta.Threads.RunCreateParams, \"assistant_id\"> {\n  assistant: Assistant;\n}\n", "import { OpenAI } from \"openai\";\n\nimport { Assistant, Context } from \"./index.js\";\nimport { Run } from \"./run.js\";\nimport { Thread } from \"./thread.js\";\nimport { createWrappedPage, StatefulObject } from \"./utils.js\";\n\nexport interface MessageEvents {}\n\nexport class Message extends StatefulObject<\n  Message,\n  OpenAI.Beta.Threads.Messages.ThreadMessage,\n  MessageEvents\n> {\n  constructor(\n    ctx: Context,\n    public thread: Thread,\n    id: string,\n  ) {\n    super(ctx, Message.object, id);\n  }\n\n  static readonly object = \"message\";\n  readonly object = Message.object;\n\n  get createdAt() {\n    return new Date(this.wrappedValue.created_at * 1000);\n  }\n  get content() {\n    return this.wrappedValue.content;\n  }\n  get assistant() {\n    return this.wrappedValue.assistant_id\n      ? new Assistant(this._ctx, this.wrappedValue.assistant_id)\n      : null;\n  }\n  get fileIds() {\n    return this.wrappedValue.file_ids;\n  }\n  get metadata() {\n    return this.wrappedValue.metadata;\n  }\n  get role() {\n    return this.wrappedValue.role;\n  }\n  get run() {\n    return this.wrappedValue.run_id\n      ? new Run(this._ctx, this.thread, this.wrappedValue.run_id)\n      : null;\n  }\n\n  /** Creates a message */\n  static async create(\n    ctx: Context,\n    thread: Thread,\n    params: OpenAI.Beta.Threads.MessageCreateParams,\n    options: OpenAI.RequestOptions = {},\n  ) {\n    const message = await ctx.client.beta.threads.messages.create(\n      thread.id,\n      params,\n      options,\n    );\n    ctx.cache.set(this.object, message.id, message);\n    ctx.cache._emit(\"created\", this.object, message.id, message);\n    const created = new Message(ctx, thread, message.id);\n    return created;\n  }\n\n  /** Constructs a new Message object by fetching by id or returning from cache if already present. */\n  static async load(\n    ctx: Context,\n    thread: Thread,\n    id: string,\n    options?: OpenAI.RequestOptions,\n  ) {\n    const message = new Message(ctx, thread, id);\n    await message.load(options);\n    return message;\n  }\n\n  /** Modifies a message */\n  async update(\n    params: OpenAI.Beta.Threads.MessageUpdateParams,\n    options: OpenAI.RequestOptions = {},\n  ) {\n    const result = await this._ctx.client.beta.threads.messages.update(\n      this.thread.id,\n      this.id,\n      params,\n      options,\n    );\n    this._cache.set(this.object, this.id, result);\n    return this;\n  }\n\n  /**\n   * Returns a list of messages from a thread.\n   */\n  static async list(\n    ctx: Context,\n    thread: Thread,\n    options: OpenAI.RequestOptions = {},\n  ) {\n    const page = await ctx.client.beta.threads.messages.list(\n      thread.id,\n      ctx._opts(options),\n    );\n    return createWrappedPage(\n      ctx,\n      page,\n      (ctx, id) => new Message(ctx, thread, id),\n    );\n  }\n\n  /**\n   * Returns a list of files from a message. Files aren't cached.\n   */\n  async listFiles(\n    query?: OpenAI.Beta.Threads.Messages.Files.FileListParams,\n    options: OpenAI.RequestOptions = {},\n  ) {\n    const page = await this._ctx.client.beta.threads.messages.files.list(\n      this.thread.id,\n      this.id,\n      query,\n      this._ctx._opts(options),\n    );\n    return page;\n  }\n\n  /**\n   * Gets a file by id. Files aren't cached.\n   */\n  async fetchFile(id: string, options: OpenAI.RequestOptions = {}) {\n    const file = await this._ctx.client.beta.threads.messages.files.retrieve(\n      this.thread.id,\n      this.id,\n      id,\n      this._ctx._opts(options),\n    );\n    return file;\n  }\n}\n", "import { OpenAI } from \"openai\";\n\nimport { Assistant, Context } from \"./index.js\";\nimport { Message } from \"./message.js\";\nimport { Run, RunCreateParams } from \"./run.js\";\nimport { StatefulObject } from \"./utils.js\";\n\nexport interface ThreadEvents {}\n\nexport class Thread extends StatefulObject<\n  Thread,\n  OpenAI.Beta.Thread,\n  ThreadEvents\n> {\n  constructor(ctx: Context, id: string) {\n    super(ctx, Thread.object, id);\n  }\n\n  static readonly object = \"thread\";\n  readonly object = Thread.object;\n  get createdAt() {\n    return new Date(this.wrappedValue.created_at * 1000);\n  }\n  get metadata() {\n    return this.wrappedValue.metadata;\n  }\n\n  /** Constructs a new Thread object by fetching by id or returning from cache if already present. */\n  static async load(ctx: Context, id: string, options?: OpenAI.RequestOptions) {\n    const thread = new Thread(ctx, id);\n    await thread.load(options);\n    return thread;\n  }\n\n  /** Creates a Thread. */\n  static async create(\n    ctx: Context,\n    params: OpenAI.Beta.ThreadCreateParams,\n    options: OpenAI.RequestOptions = {},\n  ) {\n    const thread = await ctx.client.beta.threads.create(\n      params,\n      ctx._opts(options),\n    );\n    ctx.cache.set(this.object, thread.id, thread);\n    ctx.cache._emit(\"created\", this.object, thread.id, thread);\n    return new Thread(ctx, thread.id);\n  }\n\n  /** Creates a Thread and runs it (creates a Run also). */\n  static async createAndRun(\n    ctx: Context,\n    params: ThreadCreateAndRunParams,\n    options: OpenAI.RequestOptions = {},\n  ) {\n    const { assistant, ...rest } = params;\n    const runParams = { ...rest, assistant_id: assistant.id };\n\n    // Create the run and thread\n    const _run = await ctx.client.beta.threads.createAndRun(\n      runParams,\n      ctx._opts(options),\n    );\n    ctx.cache.set(Run.object, _run.id, _run);\n    const run = new Run(\n      ctx,\n      await Thread.load(ctx, _run.thread_id, options),\n      _run.id,\n    );\n    run.beginPolling();\n\n    // Emit the created events\n    ctx.cache._emit(\n      \"created\",\n      Thread.object,\n      _run.thread_id,\n      ctx.cache.get(Thread.object, _run.thread_id),\n    );\n    ctx.cache._emit(\"created\", Run.object, _run.id, _run);\n\n    return run;\n  }\n\n  /** Runs the thread. */\n  async run(assistant: Assistant, options?: OpenAI.RequestOptions) {\n    const run = await Run.create(this._ctx, this, { assistant }, options);\n    return run;\n  }\n\n  /** Modifies this Thread. */\n  async update(\n    params: OpenAI.Beta.ThreadUpdateParams,\n    options: OpenAI.RequestOptions = {},\n  ) {\n    const updated = await this._ctx.client.beta.threads.update(\n      this.wrappedValue.id,\n      params,\n      this._ctx._opts(options),\n    );\n    this._cache.set(this.object, updated.id, updated);\n    return this;\n  }\n\n  /* Creates a new message and a new run which will auto-poll for status changes. Returns a tuple. */\n  async createMessageAndRun(\n    msgParams: OpenAI.Beta.Threads.MessageCreateParams,\n    runParams: RunCreateParams,\n    options: OpenAI.RequestOptions = {},\n  ) {\n    const message = await Message.create(this._ctx, this, msgParams, options);\n    const run = await Run.create(this._ctx, this, runParams, options);\n    return [message, run] satisfies [Message, Run];\n  }\n\n  async messages(options: OpenAI.RequestOptions = {}) {\n    return await Message.list(this._ctx, this, options);\n  }\n}\n\nexport interface ThreadCreateAndRunParams\n  extends Omit<OpenAI.Beta.ThreadCreateAndRunParams, \"assistant_id\"> {\n  assistant: Assistant;\n}\n"],
  "mappings": "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",
  "names": ["Context", "import_tiny_typed_emitter", "page", "ctx", "ctx", "ctx", "Context"]
}
