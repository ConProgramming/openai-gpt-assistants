{
  "version": 3,
  "sources": ["../src/cache.ts"],
  "sourcesContent": ["import { OpenAI } from \"openai\";\nimport { TypedEmitter } from \"tiny-typed-emitter\";\n\nimport { Context } from \"./index.js\";\n\nexport type ObjectType = \"assistant\" | \"thread\" | \"message\" | \"run\";\nexport type Id = string;\ninterface CacheEvents<T> {\n  cacheInserted: (object: ObjectType, id: Id, value: T) => void;\n  updated: (object: ObjectType, id: Id, value: T) => void;\n  cacheRemoved: (object: ObjectType, id: Id, value: T) => void;\n  fetched: (object: ObjectType, id: Id, value: T) => void;\n  created: (object: ObjectType, id: Id, value: T) => void;\n  deleted: (object: ObjectType, id: Id, value: T) => void;\n}\nexport interface CacheItemEvents<T> {\n  cacheInserted: (id: Id, value: T) => void;\n  updated: (id: Id, value: T) => void;\n  cacheRemoved: (id: Id, value: T) => void;\n  fetched: (id: Id, value: T) => void;\n  created: (id: Id, value: T) => void;\n  deleted: (id: Id, value: T) => void;\n}\ninterface ObjectCacheItem<T> {\n  value: T;\n  emitter: TypedEmitter<CacheItemEvents<T>>;\n}\ninterface ObjectCache<T> {\n  data: Record<Id, ObjectCacheItem<T>>;\n  emitter: TypedEmitter<CacheItemEvents<T>>;\n}\nexport class Cache {\n  private _emitter = new TypedEmitter<CacheEvents<any>>();\n\n  private _cache: Record<ObjectType, ObjectCache<any>> = {\n    assistant: {\n      data: {},\n      emitter: new TypedEmitter<CacheItemEvents<any>>(),\n    },\n    thread: {\n      data: {},\n      emitter: new TypedEmitter<CacheItemEvents<any>>(),\n    },\n    message: {\n      data: {},\n      emitter: new TypedEmitter<CacheItemEvents<any>>(),\n    },\n    run: {\n      data: {},\n      emitter: new TypedEmitter<CacheItemEvents<any>>(),\n    },\n  };\n\n  constructor(private ctx: Context) {}\n\n  /**\n   * Returns the emitter for the entire cache; emits events for all objects.\n   */\n  emitter<T = any>(): TypedEmitter<CacheEvents<T>>;\n  /**\n   * Returns the emitter for a specific object type; emits events for all items of that type.\n   * @param object The object type to get the emitter for.\n   * @throws If the object type is invalid\n   */\n  emitter<T = any>(object: ObjectType): TypedEmitter<CacheItemEvents<T>>;\n  /**\n   * Returns the emitter for a specific object type and id; emits events for that specific item.\n   * @param object The object type\n   * @param id The id of the object\n   * @throws If the object type is invalid or the cache is empty for that id\n   */\n  emitter<T = any>(\n    object: ObjectType,\n    id: Id,\n  ): TypedEmitter<CacheItemEvents<T>>;\n  emitter<T = any>(object?: ObjectType, id?: Id) {\n    if (!object) return this._emitter as TypedEmitter<CacheEvents<T>>;\n\n    const cache = this._cache[object];\n    if (!cache) throw new Error(`Invalid object type ${object} to get emitter`);\n\n    if (!id) return cache.emitter as TypedEmitter<CacheItemEvents<T>>;\n\n    const item = cache.data[id];\n    if (!item)\n      throw new Error(`Cannot get emitter when cache is empty for id ${id}`);\n\n    return item.emitter as TypedEmitter<CacheItemEvents<T>>;\n  }\n\n  /**\n   * Emits an event for an item in the cache, the object type, and the entire cache.\n   */\n  _emit<T>(event: keyof CacheEvents<T>, object: ObjectType, id: Id, value?: T) {\n    this.emitter().emit(event, object, id, value);\n    this.emitter(object).emit(event, id, value);\n    this.emitter(object, id).emit(event, id, value);\n  }\n\n  /**\n   * Fetches an object from the API and caches it.\n   * First emits either 'cacheInserted' or 'updated' events, then emits a 'fetched' event.\n   * @param object ObjectType to fetch\n   * @param id Id of the object to fetch. For 'message' and 'run' objects, this is an object with a threadId and id property.\n   * @param options OpenAI.OpenAI.RequestOptions to pass to the fetch\n   * @throws If the object type is invalid\n   * @returns The fetched object\n   */\n  async fetch<T>(\n    object: ObjectType,\n    id: Id | { threadId: Id; id: Id },\n    options: OpenAI.RequestOptions = {},\n  ): Promise<T> {\n    let result: T;\n    const opts = this.ctx._opts(options);\n    switch (object) {\n      case \"assistant\":\n        if (typeof id !== \"string\")\n          throw new Error(`Invalid id type ${typeof id} to fetch an ${object}`);\n        result = (await this.ctx.client.beta.assistants.retrieve(\n          id,\n          opts,\n        )) as T;\n        break;\n      case \"thread\":\n        if (typeof id !== \"string\")\n          throw new Error(`Invalid id type ${typeof id} to fetch an ${object}`);\n        result = (await this.ctx.client.beta.threads.retrieve(id, opts)) as T;\n        break;\n      case \"message\":\n        if (typeof id !== \"object\")\n          throw new Error(`Invalid id type ${typeof id} to fetch an ${object}`);\n        result = (await this.ctx.client.beta.threads.messages.retrieve(\n          id.threadId,\n          id.id,\n          opts,\n        )) as T;\n        break;\n      case \"run\":\n        if (typeof id !== \"object\")\n          throw new Error(`Invalid id type ${typeof id} to fetch an ${object}`);\n        result = (await this.ctx.client.beta.threads.runs.retrieve(\n          id.threadId,\n          id.id,\n          opts,\n        )) as T;\n        break;\n      default:\n        throw new Error(`Invalid object type ${object} to fetch`);\n    }\n    const stringId: string = typeof id === \"object\" ? (id as any).id : id;\n    this.set(object, stringId, result);\n    this._emit(\"fetched\", object, stringId, result);\n    return result;\n  }\n\n  /**\n   * Returns an object from the cache, or fetches it from the API if it's not in the cache, emitting events in the process.\n   * @param object Object type\n   * @param id Object id\n   * @throws If the object type is invalid\n   */\n  async getOrFetch<T = any>(\n    object: ObjectType,\n    id: Id,\n    options?: OpenAI.RequestOptions,\n  ): Promise<T> {\n    const cache = this._cache[object] as ObjectCache<T>;\n    if (!cache) throw new Error(`Invalid object type ${object} to getOrFetch`);\n    const existing = cache.data[id];\n    if (existing) return existing.value;\n    return await this.fetch<T>(object, id, options);\n  }\n\n  /**\n   * Gets an object from the cache\n   * @param object Object type\n   * @param id Object id\n   * @throws If the object type is invalid\n   * @returns The object or undefined if it's not in the cache\n   */\n  get<T = any>(object: ObjectType, id: Id) {\n    const cache = this._cache[object] as ObjectCache<T>;\n    if (!cache) throw new Error(`Invalid object type ${object} to get`);\n    return (this._cache[object] as ObjectCache<T>).data[id]?.value;\n  }\n\n  /**\n   * Sets an object in the cache. If it already exists, emits an 'updated' event, otherwise emits an 'cacheInserted' event.\n   * @param object Object type\n   * @param id Object id\n   * @param value Value to insert\n   * @throws If the object type is invalid\n   */\n  set<T>(object: ObjectType, id: Id, value: T) {\n    const cache = this._cache[object] as ObjectCache<T>;\n    if (!cache) throw new Error(`Invalid object type ${object} to set`);\n    if (cache.data[id]) {\n      const data = cache.data[id]!;\n      if (data.value === value) return;\n      data.value = value;\n      this._emit(\"updated\", object, id, value);\n    } else {\n      cache.data[id] = {\n        value,\n        emitter: new TypedEmitter<CacheItemEvents<T>>(),\n      };\n      this._emit(\"cacheInserted\", object, id, value);\n    }\n  }\n\n  /** Removes an item from the cache. Emits a 'cacheRemoved' event. */\n  remove<T>(object: ObjectType, id: Id) {\n    const cache = this._cache[object] as ObjectCache<T>;\n    if (!cache) throw new Error(`Invalid object type ${object} to remove`);\n    if (cache.data[id]) {\n      const data = cache.data[id]!;\n      this._emit(\"cacheRemoved\", object, id);\n      data.emitter.removeAllListeners();\n      delete cache.data[id];\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
